/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common/http'), require('@angular/core'), require('@angular/platform-browser'), require('rxjs/observable/of'), require('rxjs/operators/filter'), require('rxjs/operators/tap'), require('rxjs/operators/take')) :
	typeof define === 'function' && define.amd ? define('@nguniversal/common', ['exports', '@angular/common/http', '@angular/core', '@angular/platform-browser', 'rxjs/observable/of', 'rxjs/operators/filter', 'rxjs/operators/tap', 'rxjs/operators/take'], factory) :
	(factory((global.nguniversal = global.nguniversal || {}, global.nguniversal.common = {}),global.ng.common.http,global.ng.core,global.ng.platformBrowser,global.Rx.Observable,global.Rx.operators,global.Rx.operators,global.Rx.operators));
}(this, (function (exports,http,core,platformBrowser,of,filter,tap,take) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} headers
 * @return {?}
 */
function getHeadersMap(headers) {
    var /** @type {?} */ headersMap = {};
    for (var _i = 0, _a = headers.keys(); _i < _a.length; _i++) {
        var key = _a[_i];
        headersMap[key] = /** @type {?} */ ((headers.getAll(key)));
    }
    return headersMap;
}
var TransferHttpCacheInterceptor = /** @class */ (function () {
    function TransferHttpCacheInterceptor(appRef, transferState) {
        var _this = this;
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        appRef.isStable
            .pipe(filter.filter(function (isStable) { return isStable; }), take.take(1)).toPromise()
            .then(function () { _this.isCacheActive = false; });
    }
    /**
     * @param {?} url
     * @return {?}
     */
    TransferHttpCacheInterceptor.prototype.invalidateCacheEntry = /**
     * @param {?} url
     * @return {?}
     */
    function (url) {
        this.transferState.remove(platformBrowser.makeStateKey('G.' + url));
        this.transferState.remove(platformBrowser.makeStateKey('H.' + url));
    };
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    TransferHttpCacheInterceptor.prototype.intercept = /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    function (req, next) {
        var _this = this;
        // Stop using the cache if there is a mutating call.
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            this.isCacheActive = false;
            this.invalidateCacheEntry(req.url);
        }
        if (!this.isCacheActive) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        var /** @type {?} */ key = (req.method === 'GET' ? 'G.' : 'H.') + req.url;
        var /** @type {?} */ storeKey = platformBrowser.makeStateKey(key);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            var /** @type {?} */ response = this.transferState.get(storeKey, /** @type {?} */ ({}));
            return of.of(new http.HttpResponse({
                body: response.body,
                headers: new http.HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            var /** @type {?} */ httpEvent = next.handle(req);
            return httpEvent
                .pipe(tap.tap(function (event) {
                if (event instanceof http.HttpResponse) {
                    _this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: /** @type {?} */ ((event.url)),
                    });
                }
            }));
        }
    };
    TransferHttpCacheInterceptor.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    TransferHttpCacheInterceptor.ctorParameters = function () { return [
        { type: core.ApplicationRef, },
        { type: platformBrowser.TransferState, },
    ]; };
    return TransferHttpCacheInterceptor;
}());
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
var TransferHttpCacheModule = /** @class */ (function () {
    function TransferHttpCacheModule() {
    }
    TransferHttpCacheModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [platformBrowser.BrowserTransferStateModule],
                    providers: [
                        TransferHttpCacheInterceptor,
                        { provide: http.HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                    ],
                },] },
    ];
    /** @nocollapse */
    TransferHttpCacheModule.ctorParameters = function () { return []; };
    return TransferHttpCacheModule;
}());

exports.TransferHttpCacheModule = TransferHttpCacheModule;
exports.Éµa = TransferHttpCacheInterceptor;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=common.umd.js.map
